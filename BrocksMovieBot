import discord
from discord import app_commands
from discord.ext import commands
from discord.ui import Select, View
import requests
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from datetime import datetime
import os
from rapidfuzz import fuzz

# ======== Configuration ========
DISCORD_BOT_TOKEN = os.getenv('DISCORD_BOT_TOKEN')
TMDB_API_KEY = os.getenv('TMDB_API_KEY')
GOOGLE_CREDS_FILE = 'google-creds.json'
GOOGLE_SHEET_NAME = 'Brocks Movie Review'

# ======== Setup Google Sheets client ========
scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
creds = ServiceAccountCredentials.from_json_keyfile_name(GOOGLE_CREDS_FILE, scope)
client = gspread.authorize(creds)
sheet = client.open(GOOGLE_SHEET_NAME).worksheet('Ratings')

# ======== Define bot class with intents ========
class MyBot(commands.Bot):
    def __init__(self):
        intents = discord.Intents.default()
        intents.message_content = True
        super().__init__(command_prefix="!", intents=intents)

    async def setup_hook(self):
        await self.tree.sync()

bot = MyBot()

# ======== Movie select dropdown UI ========
class MovieSelect(Select):
    def __init__(self, options, rating):
        super().__init__(placeholder="Choose a movie...", min_values=1, max_values=1, options=options)
        self.rating = rating

    async def callback(self, interaction: discord.Interaction):
        selected_movie_id = int(self.values[0])
        details = fetch_movie_details_by_id(selected_movie_id)
        movie = parse_movie_details(details)

        watch_date = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')

        sheet.append_row([
            movie['title'],
            movie['genre'],
            self.rating,
            movie['runtime'],
            watch_date,
            movie['release_year'],
            movie['directors'],
            movie['actors'],
            movie['age_rating']
        ])

        await interaction.response.edit_message(content=f"Your rating of {self.rating}/5 for '{movie['title']}' recorded successfully!", view=None)

class MovieSelectView(View):
    def __init__(self, options, rating):
        super().__init__()
        self.add_item(MovieSelect(options, rating))

# ======== Movie functions ========
def fetch_movie_search_results(title):
    search_url = f"https://api.themoviedb.org/3/search/movie?api_key={TMDB_API_KEY}&query={title}"
    response = requests.get(search_url).json()
    return response.get('results', [])

def choose_best_movie(title, results):
    lower_title = title.lower()
    scored_results = []

    for movie in results:
        candidate_title = movie.get('title', '').lower()
        similarity = fuzz.ratio(lower_title, candidate_title)
        popularity = movie.get('popularity', 0)
        combined_score = similarity * 0.7 + popularity * 0.3
        scored_results.append((combined_score, movie))

    scored_results.sort(key=lambda x: x[0], reverse=True)
    return scored_results

def fetch_movie_details_by_id(movie_id):
    details_url = f"https://api.themoviedb.org/3/movie/{movie_id}?api_key={TMDB_API_KEY}&append_to_response=credits,release_dates"
    return requests.get(details_url).json()

def parse_movie_details(details):
    genres = ', '.join([g['name'] for g in details.get('genres', [])])
    runtime = details.get('runtime', 'N/A')
    release_year = details.get('release_date', '')[:4]
    directors = [c['name'] for c in details['credits']['crew'] if c['job'] == 'Director']
    actors = [a['name'] for a in details['credits']['cast'][:3]]

    certification = 'N/A'
    release_dates_data = details.get('release_dates', {}).get('results', [])
    for country_info in release_dates_data:
        if country_info.get('iso_3166_1') == 'US':
            for release in country_info.get('release_dates', []):
                if release.get('certification'):
                    certification = release['certification']
                    break
            if certification != 'N/A':
                break

    return {
        'title': details.get('title', 'N/A'),
        'genre': genres,
        'runtime': runtime,
        'release_year': release_year,
        'directors': ', '.join(directors) if directors else 'N/A',
        'actors': ', '.join(actors) if actors else 'N/A',
        'age_rating': certification
    }

async def handle_movie_selection(interaction, title, rating):
    results = fetch_movie_search_results(title)
    if not results:
        await interaction.followup.send(f"Sorry, could not find movie '{title}'.")
        return

    scored_results = choose_best_movie(title, results)

    if scored_results[0][0] < 75 or (len(scored_results) > 1 and scored_results[0][0] - scored_results[1][0] < 5):
        select_options = [
            discord.SelectOption(
                label=f"{m['title']} ({m.get('release_date', '')[:4]})",
                value=str(m['id'])
            )
            for _, m in scored_results[:5]
        ]
        view = MovieSelectView(select_options, rating)
        await interaction.followup.send("Multiple possible movies found. Please select the correct one:", view=view, ephemeral=True)
        return

    movie_id = scored_results[0][1]['id']
    details = fetch_movie_details_by_id(movie_id)
    movie = parse_movie_details(details)

    watch_date = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')

    sheet.append_row([
        movie['title'],
        movie['genre'],
        rating,
        movie['runtime'],
        watch_date,
        movie['release_year'],
        movie['directors'],
        movie['actors'],
        movie['age_rating']
    ])
    await interaction.followup.send(f"Your rating of {rating}/5 for '{movie['title']}' (Age Rating: {movie['age_rating']}) has been recorded!")

# ======== Rate Command ========
@bot.tree.command(name="rate", description="Rate a movie")
@app_commands.describe(title="Movie title to rate", rating="Rating from 0 to 5")
async def rate_command(interaction: discord.Interaction, title: str, rating: float):
    if rating < 0 or rating > 5:
        await interaction.response.send_message("Please provide a rating between 0 and 5.", ephemeral=True)
        return

    await interaction.response.defer()
    await handle_movie_selection(interaction, title, rating)

# ======== WATCHLIST Commands ========
@bot.tree.command(name="watchlist", description="Manage your watchlist")
@app_commands.describe(action="add/list/remove/mark", movie="Movie name")
async def watchlist(interaction: discord.Interaction, action: str, movie: str = None):
    await interaction.response.defer(ephemeral=True)
    
    # Open Watchlists tab
    watchlist_sheet = client.open(GOOGLE_SHEET_NAME).worksheet('Watchlists')
    
    if action == "add" and movie:
        results = fetch_movie_search_results(movie)
        if not results:
            await interaction.followup.send("‚ùå No movies found!")
            return
        
        scored_results = choose_best_movie(movie, results)
        movie_id = scored_results[0][1]['id']
        details = fetch_movie_details_by_id(movie_id)
        movie = parse_movie_details(details)
        
        watchlist_sheet.append_row([
            movie['title'], movie['release_year'], movie['directors'],
            movie['actors'], '',  # Empty Rating
            datetime.now().strftime('%Y-%m-%d %H:%M'), 'Pending'
        ])
        await interaction.followup.send(f"‚úÖ Added **{movie['title']}** to watchlist!")
    
    elif action == "list":
        records = watchlist_sheet.get_all_records()
        if not records:
            await interaction.followup.send("Watchlist empty! `/watchlist add <movie>`")
            return
        
        embed = discord.Embed(title=f"Watchlist ({len(records)} movies)")
        for movie_data in records[:10]:
            status = "üü° Pending" if movie_data['Status'] == 'Pending' else "‚úÖ Watched"
            rating = movie_data['Rating'] if movie_data['Rating'] else "No rating"
            embed.add_field(
                name=f"{movie_data['Movie Title']} ({movie_data['Year']}) {status}",
                value=f"{movie_data['Directors'][:50]}... | {rating}", inline=False
            )
        await interaction.followup.send(embed=embed)
    
    elif action == "remove" and movie:
        records = watchlist_sheet.get_all_records()
        for i, row in enumerate(records):
            if movie.lower() in row['Movie Title'].lower():
                watchlist_sheet.delete_rows(i+2)
                await interaction.followup.send(f"‚úÖ Removed **{row['Movie Title']}**!")
                return
        await interaction.followup.send("‚ùå Movie not found!")
    
    elif action == "mark" and movie:
        records = watchlist_sheet.get_all_records()
        for i, row in enumerate(records):
            if movie.lower() in row['Movie Title'].lower():
                watchlist_sheet.update_cell(i+2, 7, 'Watched')
                await interaction.followup.send(f"‚úÖ Marked **{row['Movie Title']}** as Watched!")
                return
        await interaction.followup.send("‚ùå Movie not found!")
    
    else:
        await interaction.followup.send("Use: `/watchlist add <movie>`, `/watchlist list`, `/watchlist remove <movie>`, `/watchlist mark <movie>`")

# ======== Run the bot ========
bot.run(DISCORD_BOT_TOKEN)
